import { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import { useWeb3 } from '../contexts/Web3Context';
import {
  AAVE_CONFIG,
  AAVE_POOL_ABI,
  AAVE_DATA_PROVIDER_ABI,
  ERC20_ABI,
  getAaveConfig,
  isAaveSupported,
  formatNumber,
  formatApy,
} from '../config/aave';
import toast from 'react-hot-toast';

export interface AaveUserData {
  totalCollateral: string;
  totalDebt: string;
  availableBorrows: string;
  currentLiquidationThreshold: string;
  ltv: string;
  healthFactor: string;
}

export interface AaveDepositData {
  currentATokenBalance: string;
  liquidityRate: string;
  totalSupplied: string;
  apy: string;
}

export const useAave = () => {
  const { provider, signer, address, chainId } = useWeb3();

  // Áä∂ÊÄÅÁÆ°ÁêÜ
  const [isLoading, setIsLoading] = useState(false);
  const [isConfirmed, setIsConfirmed] = useState(false);
  const [transactionHash, setTransactionHash] = useState<string>('');
  const [usdtBalance, setUsdtBalance] = useState('0');
  const [aUsdtBalance, setAUsdtBalance] = useState('0');
  const [allowance, setAllowance] = useState('0');
  const [depositData, setDepositData] = useState<AaveDepositData>({
    currentATokenBalance: '0',
    liquidityRate: '0',
    totalSupplied: '0',
    apy: '0',
  });
  const [userData, setUserData] = useState<AaveUserData>({
    totalCollateral: '0',
    totalDebt: '0',
    availableBorrows: '0',
    currentLiquidationThreshold: '0',
    ltv: '0',
    healthFactor: '0',
  });

  // Ëé∑ÂèñÂΩìÂâçÁΩëÁªúÈÖçÁΩÆ
  const aaveConfig = chainId ? getAaveConfig(chainId) : null;
  const isNetworkSupported = chainId ? isAaveSupported(chainId) : false;

  // ÂêàÁ∫¶ÂÆû‰æã
  const getPoolContract = useCallback(() => {
    if (!signer || !aaveConfig) return null;
    return new ethers.Contract(aaveConfig.poolAddress, AAVE_POOL_ABI, signer);
  }, [signer, aaveConfig]);

  const getDataProviderContract = useCallback(() => {
    if (!provider || !aaveConfig) return null;
    return new ethers.Contract(
      aaveConfig.poolDataProvider,
      AAVE_DATA_PROVIDER_ABI,
      provider
    );
  }, [provider, aaveConfig]);

  const getUsdtContract = useCallback(() => {
    if (!provider || !aaveConfig) return null;
    return new ethers.Contract(aaveConfig.usdtAddress, ERC20_ABI, provider);
  }, [provider, aaveConfig]);

  const getUsdtContractWithSigner = useCallback(() => {
    if (!signer || !aaveConfig) return null;
    return new ethers.Contract(aaveConfig.usdtAddress, ERC20_ABI, signer);
  }, [signer, aaveConfig]);

  const getAUsdtContract = useCallback(() => {
    if (!provider || !aaveConfig) return null;
    return new ethers.Contract(aaveConfig.aUsdtAddress, ERC20_ABI, provider);
  }, [provider, aaveConfig]);

  // Ëé∑ÂèñUSDT‰ΩôÈ¢ù
  const fetchUsdtBalance = useCallback(async () => {
    if (!address || !aaveConfig) return;

    try {
      const usdtContract = getUsdtContract();
      if (!usdtContract) return;

      const balance = await usdtContract.balanceOf(address);
      const decimals = await usdtContract.decimals();
      const formattedBalance = ethers.utils.formatUnits(balance, decimals);
      setUsdtBalance(formattedBalance);
    } catch (error) {
      console.error('Ëé∑ÂèñUSDT‰ΩôÈ¢ùÂ§±Ë¥•:', error);
      setUsdtBalance('0');
    }
  }, [address, aaveConfig, getUsdtContract]);

  // Ëé∑ÂèñaUSDT‰ΩôÈ¢ù
  const fetchAUsdtBalance = useCallback(async () => {
    if (!address || !aaveConfig) return;

    try {
      const aUsdtContract = getAUsdtContract();
      if (!aUsdtContract) return;

      const balance = await aUsdtContract.balanceOf(address);
      const decimals = await aUsdtContract.decimals();
      const formattedBalance = ethers.utils.formatUnits(balance, decimals);
      setAUsdtBalance(formattedBalance);
    } catch (error) {
      console.error('Ëé∑ÂèñaUSDT‰ΩôÈ¢ùÂ§±Ë¥•:', error);
      setAUsdtBalance('0');
    }
  }, [address, aaveConfig, getAUsdtContract]);

  // Ëé∑ÂèñUSDTÊéàÊùÉÈ¢ùÂ∫¶
  const fetchAllowance = useCallback(async () => {
    if (!address || !aaveConfig) return;

    try {
      const usdtContract = getUsdtContract();
      if (!usdtContract) return;

      const allowanceAmount = await usdtContract.allowance(
        address,
        aaveConfig.poolAddress
      );
      const decimals = await usdtContract.decimals();
      const formattedAllowance = ethers.utils.formatUnits(allowanceAmount, decimals);
      setAllowance(formattedAllowance);
    } catch (error) {
      console.error('Ëé∑ÂèñÊéàÊùÉÈ¢ùÂ∫¶Â§±Ë¥•:', error);
      setAllowance('0');
    }
  }, [address, aaveConfig, getUsdtContract]);

  // Ëé∑ÂèñÁî®Êà∑ÂÇ®Â§áÊï∞ÊçÆ
  const fetchUserReserveData = useCallback(async () => {
    if (!address || !aaveConfig) return;

    try {
      const dataProvider = getDataProviderContract();
      if (!dataProvider) return;

      const reserveData = await dataProvider.getUserReserveData(
        aaveConfig.usdtAddress,
        address
      );

      const decimals = 6; // USDTÁöÑÂ∞èÊï∞‰ΩçÊï∞

      const depositInfo: AaveDepositData = {
        currentATokenBalance: ethers.utils.formatUnits(
          reserveData.currentATokenBalance,
          decimals
        ),
        liquidityRate: reserveData.liquidityRate.toString(),
        totalSupplied: ethers.utils.formatUnits(
          reserveData.currentATokenBalance,
          decimals
        ),
        apy: formatApy(reserveData.liquidityRate.toString()),
      };

      setDepositData(depositInfo);
    } catch (error) {
      console.error('Ëé∑ÂèñÁî®Êà∑ÂÇ®Â§áÊï∞ÊçÆÂ§±Ë¥•:', error);
      setDepositData({
        currentATokenBalance: '0',
        liquidityRate: '0',
        totalSupplied: '0',
        apy: '0',
      });
    }
  }, [address, aaveConfig, getDataProviderContract]);

  // Ëé∑ÂèñÁî®Êà∑Ë¥¶Êà∑Êï∞ÊçÆ
  const fetchUserAccountData = useCallback(async () => {
    if (!address || !aaveConfig) return;

    try {
      const poolContract = getPoolContract();
      if (!poolContract) return;

      const accountData = await poolContract.getUserAccountData(address);

      const userInfo: AaveUserData = {
        totalCollateral: ethers.utils.formatUnits(accountData.totalCollateralBase, 8), // Âü∫Á°ÄÂçï‰Ωç
        totalDebt: ethers.utils.formatUnits(accountData.totalDebtBase, 8),
        availableBorrows: ethers.utils.formatUnits(accountData.availableBorrowsBase, 8),
        currentLiquidationThreshold: (
          accountData.currentLiquidationThreshold.toNumber() / 100
        ).toString(),
        ltv: (accountData.ltv.toNumber() / 100).toString(),
        healthFactor: ethers.utils.formatUnits(accountData.healthFactor, 18),
      };

      setUserData(userInfo);
    } catch (error) {
      console.error('Ëé∑ÂèñÁî®Êà∑Ë¥¶Êà∑Êï∞ÊçÆÂ§±Ë¥•:', error);
      setUserData({
        totalCollateral: '0',
        totalDebt: '0',
        availableBorrows: '0',
        currentLiquidationThreshold: '0',
        ltv: '0',
        healthFactor: '0',
      });
    }
  }, [address, aaveConfig, getPoolContract]);

  // Âà∑Êñ∞ÊâÄÊúâÊï∞ÊçÆ
  const refetchAll = useCallback(async () => {
    if (!isNetworkSupported || !address) return;

    await Promise.all([
      fetchUsdtBalance(),
      fetchAUsdtBalance(),
      fetchAllowance(),
      fetchUserReserveData(),
      fetchUserAccountData(),
    ]);
  }, [
    isNetworkSupported,
    address,
    fetchUsdtBalance,
    fetchAUsdtBalance,
    fetchAllowance,
    fetchUserReserveData,
    fetchUserAccountData,
  ]);

  // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊéàÊùÉ
  const needsApproval = useCallback(
    (amount: string): boolean => {
      if (!amount || parseFloat(amount) <= 0) return false;
      return parseFloat(amount) > parseFloat(allowance);
    },
    [allowance]
  );

  // Ê£ÄÊü•‰ΩôÈ¢ùÊòØÂê¶Ë∂≥Â§ü
  const hasEnoughBalance = useCallback(
    (amount: string): boolean => {
      if (!amount || parseFloat(amount) <= 0) return false;
      return parseFloat(amount) <= parseFloat(usdtBalance);
    },
    [usdtBalance]
  );

  // Ê£ÄÊü•ÊòØÂê¶ÊúâË∂≥Â§üÁöÑaUSDT‰ΩôÈ¢ùÁî®‰∫éÊèêÂèñ
  const hasEnoughATokenBalance = useCallback(
    (amount: string): boolean => {
      if (!amount || parseFloat(amount) <= 0) return false;
      return parseFloat(amount) <= parseFloat(aUsdtBalance);
    },
    [aUsdtBalance]
  );

  // ÊéàÊùÉUSDTÁªôAAVEÊ±†
  const approveUsdt = async (amount: string) => {
    if (!aaveConfig || !signer) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.NETWORK_NOT_SUPPORTED);
      return;
    }

    if (!hasEnoughBalance(amount)) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.INSUFFICIENT_BALANCE);
      return;
    }

    setIsLoading(true);
    setIsConfirmed(false);
    setTransactionHash('');

    try {
      const usdtContract = getUsdtContractWithSigner();
      if (!usdtContract) throw new Error('Êó†Ê≥ïËé∑ÂèñUSDTÂêàÁ∫¶');

      const decimals = await usdtContract.decimals();
      const amountInWei = ethers.utils.parseUnits(amount, decimals);

      console.log('üîê ÂºÄÂßãUSDTÊéàÊùÉ:', {
        amount,
        amountInWei: amountInWei.toString(),
        spender: aaveConfig.poolAddress,
        decimals,
      });

      const tx = await usdtContract.approve(aaveConfig.poolAddress, amountInWei);
      setTransactionHash(tx.hash);

      toast.success('ÊéàÊùÉ‰∫§ÊòìÂ∑≤Êèê‰∫§ÔºåÁ≠âÂæÖÁ°ÆËÆ§...');

      const receipt = await tx.wait();
      console.log('‚úÖ USDTÊéàÊùÉÊàêÂäü:', receipt);

      setIsConfirmed(true);
      toast.success('üéâ USDTÊéàÊùÉÊàêÂäüÔºÅ');

      // Âà∑Êñ∞ÊéàÊùÉÈ¢ùÂ∫¶
      await fetchAllowance();
    } catch (error: any) {
      console.error('‚ùå USDTÊéàÊùÉÂ§±Ë¥•:', error);
      toast.error(error.message || AAVE_CONFIG.ERROR_MESSAGES.APPROVAL_FAILED);
    } finally {
      setIsLoading(false);
    }
  };

  // Ë¥®ÊäºUSDTÂà∞AAVE
  const supplyUsdt = async (amount: string) => {
    if (!aaveConfig || !signer || !address) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.NETWORK_NOT_SUPPORTED);
      return;
    }

    if (!hasEnoughBalance(amount)) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.INSUFFICIENT_BALANCE);
      return;
    }

    if (needsApproval(amount)) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.INSUFFICIENT_ALLOWANCE);
      return;
    }

    setIsLoading(true);
    setIsConfirmed(false);
    setTransactionHash('');

    try {
      const poolContract = getPoolContract();
      if (!poolContract) throw new Error('Êó†Ê≥ïËé∑ÂèñPoolÂêàÁ∫¶');

      const usdtContract = getUsdtContract();
      if (!usdtContract) throw new Error('Êó†Ê≥ïËé∑ÂèñUSDTÂêàÁ∫¶');

      const decimals = await usdtContract.decimals();
      const amountInWei = ethers.utils.parseUnits(amount, decimals);

      console.log('üí∞ ÂºÄÂßãË¥®ÊäºUSDT:', {
        amount,
        amountInWei: amountInWei.toString(),
        asset: aaveConfig.usdtAddress,
        onBehalfOf: address,
        referralCode: AAVE_CONFIG.DEFAULT_REFERRAL_CODE,
      });

      const tx = await poolContract.supply(
        aaveConfig.usdtAddress,
        amountInWei,
        address,
        AAVE_CONFIG.DEFAULT_REFERRAL_CODE
      );

      setTransactionHash(tx.hash);
      toast.success('Ë¥®Êäº‰∫§ÊòìÂ∑≤Êèê‰∫§ÔºåÁ≠âÂæÖÁ°ÆËÆ§...');

      const receipt = await tx.wait();
      console.log('‚úÖ USDTË¥®ÊäºÊàêÂäü:', receipt);

      setIsConfirmed(true);
      toast.success('üéâ USDTË¥®ÊäºÊàêÂäüÔºÅÂºÄÂßãËµöÂèñÂà©ÊÅØ');

      // Âà∑Êñ∞ÊâÄÊúâÁõ∏ÂÖ≥Êï∞ÊçÆ
      await refetchAll();
    } catch (error: any) {
      console.error('‚ùå USDTË¥®ÊäºÂ§±Ë¥•:', error);
      toast.error(error.message || AAVE_CONFIG.ERROR_MESSAGES.SUPPLY_FAILED);
    } finally {
      setIsLoading(false);
    }
  };

  // ‰ªéAAVEÊèêÂèñUSDT
  const withdrawUsdt = async (amount: string) => {
    if (!aaveConfig || !signer || !address) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.NETWORK_NOT_SUPPORTED);
      return;
    }

    // Ê£ÄÊü•ÊèêÂèñÈáëÈ¢ù
    const isMaxWithdraw = amount === 'max';
    const withdrawAmount = isMaxWithdraw ? aUsdtBalance : amount;

    if (!isMaxWithdraw && !hasEnoughATokenBalance(amount)) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.AMOUNT_EXCEEDS_BALANCE);
      return;
    }

    if (parseFloat(aUsdtBalance) <= 0) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.NO_DEPOSITS);
      return;
    }

    setIsLoading(true);
    setIsConfirmed(false);
    setTransactionHash('');

    try {
      const poolContract = getPoolContract();
      if (!poolContract) throw new Error('Êó†Ê≥ïËé∑ÂèñPoolÂêàÁ∫¶');

      const usdtContract = getUsdtContract();
      if (!usdtContract) throw new Error('Êó†Ê≥ïËé∑ÂèñUSDTÂêàÁ∫¶');

      const decimals = await usdtContract.decimals();

      // Â¶ÇÊûúÊòØÊúÄÂ§ßÊèêÂèñÔºå‰ΩøÁî®ÁâπÊÆäÂÄº (uint256ÊúÄÂ§ßÂÄº)
      const amountInWei = isMaxWithdraw
        ? ethers.constants.MaxUint256
        : ethers.utils.parseUnits(withdrawAmount, decimals);

      console.log('üí∏ ÂºÄÂßãÊèêÂèñUSDT:', {
        amount: withdrawAmount,
        isMaxWithdraw,
        amountInWei: amountInWei.toString(),
        asset: aaveConfig.usdtAddress,
        to: address,
      });

      const tx = await poolContract.withdraw(
        aaveConfig.usdtAddress,
        amountInWei,
        address
      );

      setTransactionHash(tx.hash);
      toast.success('ÊèêÂèñ‰∫§ÊòìÂ∑≤Êèê‰∫§ÔºåÁ≠âÂæÖÁ°ÆËÆ§...');

      const receipt = await tx.wait();
      console.log('‚úÖ USDTÊèêÂèñÊàêÂäü:', receipt);

      setIsConfirmed(true);
      toast.success('üéâ USDTÊèêÂèñÊàêÂäüÔºÅ');

      // Âà∑Êñ∞ÊâÄÊúâÁõ∏ÂÖ≥Êï∞ÊçÆ
      await refetchAll();
    } catch (error: any) {
      console.error('‚ùå USDTÊèêÂèñÂ§±Ë¥•:', error);
      toast.error(error.message || AAVE_CONFIG.ERROR_MESSAGES.WITHDRAW_FAILED);
    } finally {
      setIsLoading(false);
    }
  };

  // ËÆ°ÁÆóÈ¢ÑÊúüÊî∂Áõä
  const calculateExpectedReturn = useCallback(
    (amount: string, days: number = 365): string => {
      if (!amount || parseFloat(amount) <= 0 || !depositData.apy) return '0';

      const principal = parseFloat(amount);
      const apy = parseFloat(depositData.apy) / 100; // ËΩ¨Êç¢‰∏∫Â∞èÊï∞
      const expectedReturn = principal * apy * (days / 365);

      return expectedReturn.toFixed(6);
    },
    [depositData.apy]
  );

  // ÂàùÂßãÂåñÂíåÁõëÂê¨ÂèòÂåñ
  useEffect(() => {
    if (isNetworkSupported && address && provider) {
      refetchAll();
    }
  }, [isNetworkSupported, address, provider, refetchAll]);

  // ÁõëÂê¨‰∫§ÊòìÁ°ÆËÆ§ÂêéÈáçÁΩÆÁä∂ÊÄÅ
  useEffect(() => {
    if (isConfirmed) {
      setTimeout(() => {
        setIsConfirmed(false);
        setTransactionHash('');
      }, 5000);
    }
  }, [isConfirmed]);

  return {
    // ÁΩëÁªúÁä∂ÊÄÅ
    isNetworkSupported,
    aaveConfig,
    
    // ‰ΩôÈ¢ù‰ø°ÊÅØ
    usdtBalance,
    aUsdtBalance,
    allowance,
    
    // Â≠òÊ¨æÂíåÁî®Êà∑Êï∞ÊçÆ
    depositData,
    userData,
    
    // ‰∫§ÊòìÁä∂ÊÄÅ
    isLoading,
    isConfirmed,
    transactionHash,
    
    // Ê£ÄÊü•ÂáΩÊï∞
    needsApproval,
    hasEnoughBalance,
    hasEnoughATokenBalance,
    
    // Êìç‰ΩúÂáΩÊï∞
    approveUsdt,
    supplyUsdt,
    withdrawUsdt,
    refetchAll,
    
    // ËÆ°ÁÆóÂáΩÊï∞
    calculateExpectedReturn,
    
    // Ê†ºÂºèÂåñÂáΩÊï∞
    formatNumber,
    formatApy,
  };
};
