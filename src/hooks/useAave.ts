import { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import { useWeb3 } from '../contexts/Web3Context';
import {
  AAVE_CONFIG,
  AAVE_POOL_ABI,
  AAVE_DATA_PROVIDER_ABI,
  ERC20_ABI,
  getAaveConfig,
  isAaveSupported,
  formatNumber,
  formatApy,
} from '../config/aave';
import toast from 'react-hot-toast';

export interface AaveUserData {
  totalCollateral: string;
  totalDebt: string;
  availableBorrows: string;
  currentLiquidationThreshold: string;
  ltv: string;
  healthFactor: string;
}

export interface AaveDepositData {
  currentATokenBalance: string;
  liquidityRate: string;
  totalSupplied: string;
  apy: string;
}

export const useAave = () => {
  const { provider, signer, address, chainId } = useWeb3();

  // Áä∂ÊÄÅÁÆ°ÁêÜ
  const [isLoading, setIsLoading] = useState(false);
  const [isConfirmed, setIsConfirmed] = useState(false);
  const [transactionHash, setTransactionHash] = useState<string>('');
  const [usdtBalance, setUsdtBalance] = useState('0');
  const [aUsdtBalance, setAUsdtBalance] = useState('0');
  const [allowance, setAllowance] = useState('0');
  const [depositData, setDepositData] = useState<AaveDepositData>({
    currentATokenBalance: '0',
    liquidityRate: '0',
    totalSupplied: '0',
    apy: '0',
  });
  const [userData, setUserData] = useState<AaveUserData>({
    totalCollateral: '0',
    totalDebt: '0',
    availableBorrows: '0',
    currentLiquidationThreshold: '0',
    ltv: '0',
    healthFactor: '0',
  });

  // Ëé∑ÂèñÂΩìÂâçÁΩëÁªúÈÖçÁΩÆ
  const aaveConfig = chainId ? getAaveConfig(chainId) : null;
  const isNetworkSupported = chainId ? isAaveSupported(chainId) : false;

  // ÂêàÁ∫¶ÂÆû‰æã
  const getPoolContract = useCallback(() => {
    if (!signer || !aaveConfig) return null;
    return new ethers.Contract(aaveConfig.poolAddress, AAVE_POOL_ABI, signer);
  }, [signer, aaveConfig]);

  const getDataProviderContract = useCallback(() => {
    if (!provider || !aaveConfig) return null;
    return new ethers.Contract(
      aaveConfig.poolDataProvider,
      AAVE_DATA_PROVIDER_ABI,
      provider
    );
  }, [provider, aaveConfig]);

  // Â¢ûÂº∫ÁöÑUSDTÂêàÁ∫¶ÂÆû‰æãÂàõÂª∫ÂáΩÊï∞
  const getUsdtContract = useCallback(() => {
    if (!provider || !aaveConfig) {
      console.log('üîç Êó†Ê≥ïÂàõÂª∫USDTÂêàÁ∫¶ÔºöÁº∫Â∞ëproviderÊàñÈÖçÁΩÆ', {
        hasProvider: !!provider,
        hasConfig: !!aaveConfig
      });
      return null;
    }

    try {
      console.log('üîß ÂàõÂª∫USDTÂêàÁ∫¶ÂÆû‰æã:', {
        address: aaveConfig.usdtAddress,
        chainId: aaveConfig.chainId
      });

      return new ethers.Contract(aaveConfig.usdtAddress, ERC20_ABI, provider);
    } catch (error) {
      console.error('‚ùå ÂàõÂª∫USDTÂêàÁ∫¶Â§±Ë¥•:', error);
      return null;
    }
  }, [provider, aaveConfig]);

  const getUsdtContractWithSigner = useCallback(() => {
    if (!signer || !aaveConfig) return null;
    return new ethers.Contract(aaveConfig.usdtAddress, ERC20_ABI, signer);
  }, [signer, aaveConfig]);

  const getAUsdtContract = useCallback(() => {
    if (!provider || !aaveConfig) return null;
    return new ethers.Contract(aaveConfig.aUsdtAddress, ERC20_ABI, provider);
  }, [provider, aaveConfig]);

  // ‰øÆÂ§çÁöÑUSDT‰ΩôÈ¢ùËé∑ÂèñÂáΩÊï∞ - ‰ΩøÁî® ethers v6 API
  const fetchUsdtBalance = useCallback(async () => {
    if (!address || !aaveConfig) {
      console.log('üîç Êó†Ê≥ïËé∑ÂèñUSDT‰ΩôÈ¢ùÔºöÁº∫Â∞ëÂú∞ÂùÄÊàñÈÖçÁΩÆ', { address, aaveConfig: !!aaveConfig });
      return;
    }

    try {
      console.log('üîç ÂºÄÂßãËé∑ÂèñUSDT‰ΩôÈ¢ù...', {
        address,
        usdtAddress: aaveConfig.usdtAddress,
        chainId: aaveConfig.chainId
      });

      const usdtContract = getUsdtContract();
      if (!usdtContract) {
        console.error('‚ùå Êó†Ê≥ïÂàõÂª∫USDTÂêàÁ∫¶ÂÆû‰æã');
        setUsdtBalance('0');
        return;
      }

      // Ê∑ªÂä†Ë∂ÖÊó∂Êú∫Âà∂
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Ëé∑Âèñ‰ΩôÈ¢ùË∂ÖÊó∂')), 10000)
      );

      // È¶ñÂÖàÈ™åËØÅÂêàÁ∫¶Âú∞ÂùÄÊòØÂê¶ÊúâÊïà
      try {
        const code = await provider?.getCode(aaveConfig.usdtAddress);
        if (!code || code === '0x') {
          console.error('‚ùå USDTÂêàÁ∫¶Âú∞ÂùÄÊó†ÊïàÊàñ‰∏çÂ≠òÂú®', {
            address: aaveConfig.usdtAddress,
            chainId: aaveConfig.chainId
          });
          setUsdtBalance('0');
          return;
        }
      } catch (codeError) {
        console.error('‚ùå Ê£ÄÊü•ÂêàÁ∫¶‰ª£Á†ÅÂ§±Ë¥•:', codeError);
      }

      // Ëé∑Âèñ‰ΩôÈ¢ùÂíåÁ≤æÂ∫¶
      const [balance, decimals] = await Promise.race([
        Promise.all([
          usdtContract.balanceOf(address),
          usdtContract.decimals()
        ]),
        timeoutPromise
      ]) as [any, any];

      console.log('üìä ÂéüÂßã‰ΩôÈ¢ùÊï∞ÊçÆ:', {
        balance: balance.toString(),
        decimals: decimals.toString(),
        address
      });

      // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 ÁöÑ formatUnits
      const formattedBalance = ethers.formatUnits(balance, decimals);
      
      console.log('‚úÖ USDT‰ΩôÈ¢ùËé∑ÂèñÊàêÂäü:', {
        formatted: formattedBalance,
        raw: balance.toString()
      });

      setUsdtBalance(formattedBalance);

    } catch (error: any) {
      console.error('‚ùå Ëé∑ÂèñUSDT‰ΩôÈ¢ùÂ§±Ë¥•:', {
        error: error.message || error,
        address,
        usdtAddress: aaveConfig.usdtAddress,
        chainId: aaveConfig.chainId,
        stack: error.stack
      });

      // Ê†πÊçÆÈîôËØØÁ±ªÂûãÊèê‰æõÊõ¥ËØ¶ÁªÜÁöÑ‰ø°ÊÅØ
      if (error.message?.includes('timeout')) {
        toast.error('Ëé∑Âèñ‰ΩôÈ¢ùË∂ÖÊó∂ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•');
      } else if (error.message?.includes('network')) {
        toast.error('ÁΩëÁªúÈîôËØØÔºåËØ∑ÂàáÊç¢RPCËäÇÁÇπ');
      } else if (error.message?.includes('call revert')) {
        toast.error('ÂêàÁ∫¶Ë∞ÉÁî®Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúÈÖçÁΩÆ');
      }

      setUsdtBalance('0');
    }
  }, [address, aaveConfig, getUsdtContract, provider]);

  // ÈáçËØïÊú∫Âà∂ÁöÑUSDT‰ΩôÈ¢ùËé∑ÂèñÂáΩÊï∞
  const fetchUsdtBalanceWithRetry = useCallback(async (retries = 3) => {
    for (let i = 0; i < retries; i++) {
      try {
        await fetchUsdtBalance();
        break; // ÊàêÂäüÂàôÈÄÄÂá∫Âæ™ÁéØ
      } catch (error) {
        console.log(`üîÑ Á¨¨${i + 1}Ê¨°Â∞ùËØïÂ§±Ë¥•ÔºåÂâ©‰ΩôÈáçËØïÊ¨°Êï∞Ôºö${retries - i - 1}`);
        if (i === retries - 1) {
          console.error('‚ùå ÊâÄÊúâÈáçËØïÈÉΩÂ§±Ë¥•‰∫Ü');
          toast.error('Ëé∑ÂèñUSDT‰ΩôÈ¢ùÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÊàñÂàáÊç¢RPCËäÇÁÇπ');
        } else {
          // Á≠âÂæÖ‰∏ÄÊÆµÊó∂Èó¥ÂêéÈáçËØï
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }
  }, [fetchUsdtBalance]);

  // Ë∞ÉËØïÂáΩÊï∞ - ‰øÆÂ§ç ethers v6 ÂÖºÂÆπÊÄß
  const debugUsdtBalance = useCallback(async () => {
    if (!address || !aaveConfig || !provider) {
      console.log('üîç Ë∞ÉËØï‰ø°ÊÅØ - Áº∫Â∞ëÂøÖË¶ÅÊù°‰ª∂:', {
        address: !!address,
        aaveConfig: !!aaveConfig,
        provider: !!provider
      });
      return;
    }

    console.log('üîç ÂºÄÂßãË∞ÉËØïUSDT‰ΩôÈ¢ùËé∑Âèñ...');
    console.log('üìä ÂΩìÂâçÈÖçÁΩÆ:', {
      chainId: aaveConfig.chainId,
      networkName: aaveConfig.name,
      usdtAddress: aaveConfig.usdtAddress,
      userAddress: address
    });

    try {
      // Ê£ÄÊü•ÁΩëÁªúËøûÊé•
      const network = await provider.getNetwork();
      console.log('üåê ÁΩëÁªú‰ø°ÊÅØ:', network);

      // Ê£ÄÊü•ÂêàÁ∫¶‰ª£Á†Å
      const code = await provider.getCode(aaveConfig.usdtAddress);
      console.log('üìú ÂêàÁ∫¶‰ª£Á†ÅÈïøÂ∫¶:', code.length);

      // Â∞ùËØïÁõ¥Êé•Ë∞ÉÁî®ÂêàÁ∫¶
      const contract = new ethers.Contract(aaveConfig.usdtAddress, ERC20_ABI, provider);
      const [balance, decimals, symbol] = await Promise.all([
        contract.balanceOf(address),
        contract.decimals(),
        contract.symbol?.() || 'Unknown'
      ]);

      console.log('üí∞ ‰ΩôÈ¢ùË∞ÉËØïÁªìÊûú:', {
        balance: balance.toString(),
        decimals: decimals.toString(),
        symbol,
        formatted: ethers.formatUnits(balance, decimals) // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API
      });

    } catch (error) {
      console.error('‚ùå Ë∞ÉËØïËøáÁ®ã‰∏≠Âá∫Èîô:', error);
    }
  }, [address, aaveConfig, provider]);

  // Ëé∑ÂèñaUSDT‰ΩôÈ¢ù - ‰øÆÂ§ç ethers v6 ÂÖºÂÆπÊÄß
  const fetchAUsdtBalance = useCallback(async () => {
    if (!address || !aaveConfig) return;

    try {
      const aUsdtContract = getAUsdtContract();
      if (!aUsdtContract) return;

      const balance = await aUsdtContract.balanceOf(address);
      const decimals = await aUsdtContract.decimals();
      const formattedBalance = ethers.formatUnits(balance, decimals); // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API
      setAUsdtBalance(formattedBalance);
    } catch (error) {
      console.error('Ëé∑ÂèñaUSDT‰ΩôÈ¢ùÂ§±Ë¥•:', error);
      setAUsdtBalance('0');
    }
  }, [address, aaveConfig, getAUsdtContract]);

  // Ëé∑ÂèñUSDTÊéàÊùÉÈ¢ùÂ∫¶ - ‰øÆÂ§ç ethers v6 ÂÖºÂÆπÊÄß
  const fetchAllowance = useCallback(async () => {
    if (!address || !aaveConfig) return;

    try {
      const usdtContract = getUsdtContract();
      if (!usdtContract) return;

      const allowanceAmount = await usdtContract.allowance(
        address,
        aaveConfig.poolAddress
      );
      const decimals = await usdtContract.decimals();
      const formattedAllowance = ethers.formatUnits(allowanceAmount, decimals); // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API
      setAllowance(formattedAllowance);
    } catch (error) {
      console.error('Ëé∑ÂèñÊéàÊùÉÈ¢ùÂ∫¶Â§±Ë¥•:', error);
      setAllowance('0');
    }
  }, [address, aaveConfig, getUsdtContract]);

  // Ëé∑ÂèñÁî®Êà∑ÂÇ®Â§áÊï∞ÊçÆ - ‰øÆÂ§ç ethers v6 ÂÖºÂÆπÊÄß
  const fetchUserReserveData = useCallback(async () => {
    if (!address || !aaveConfig) return;

    try {
      const dataProvider = getDataProviderContract();
      if (!dataProvider) return;

      const reserveData = await dataProvider.getUserReserveData(
        aaveConfig.usdtAddress,
        address
      );

      const decimals = 6; // USDTÁöÑÂ∞èÊï∞‰ΩçÊï∞

      const depositInfo: AaveDepositData = {
        currentATokenBalance: ethers.formatUnits( // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API
          reserveData.currentATokenBalance,
          decimals
        ),
        liquidityRate: reserveData.liquidityRate.toString(),
        totalSupplied: ethers.formatUnits( // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API
          reserveData.currentATokenBalance,
          decimals
        ),
        apy: formatApy(reserveData.liquidityRate.toString()),
      };

      setDepositData(depositInfo);
    } catch (error) {
      console.error('Ëé∑ÂèñÁî®Êà∑ÂÇ®Â§áÊï∞ÊçÆÂ§±Ë¥•:', error);
      setDepositData({
        currentATokenBalance: '0',
        liquidityRate: '0',
        totalSupplied: '0',
        apy: '0',
      });
    }
  }, [address, aaveConfig, getDataProviderContract]);

  // Ëé∑ÂèñÁî®Êà∑Ë¥¶Êà∑Êï∞ÊçÆ - ‰øÆÂ§ç ethers v6 ÂÖºÂÆπÊÄß
  const fetchUserAccountData = useCallback(async () => {
    if (!address || !aaveConfig) return;

    try {
      const poolContract = getPoolContract();
      if (!poolContract) return;

      const accountData = await poolContract.getUserAccountData(address);

      const userInfo: AaveUserData = {
        totalCollateral: ethers.formatUnits(accountData.totalCollateralBase, 8), // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API
        totalDebt: ethers.formatUnits(accountData.totalDebtBase, 8), // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API
        availableBorrows: ethers.formatUnits(accountData.availableBorrowsBase, 8), // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API
        currentLiquidationThreshold: (
          Number(accountData.currentLiquidationThreshold) / 100 // ‰øÆÂ§çÔºö‰ΩøÁî® Number() Êõø‰ª£ .toNumber()
        ).toString(),
        ltv: (Number(accountData.ltv) / 100).toString(), // ‰øÆÂ§çÔºö‰ΩøÁî® Number() Êõø‰ª£ .toNumber()
        healthFactor: ethers.formatUnits(accountData.healthFactor, 18), // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API
      };

      setUserData(userInfo);
    } catch (error) {
      console.error('Ëé∑ÂèñÁî®Êà∑Ë¥¶Êà∑Êï∞ÊçÆÂ§±Ë¥•:', error);
      setUserData({
        totalCollateral: '0',
        totalDebt: '0',
        availableBorrows: '0',
        currentLiquidationThreshold: '0',
        ltv: '0',
        healthFactor: '0',
      });
    }
  }, [address, aaveConfig, getPoolContract]);

  // Âà∑Êñ∞ÊâÄÊúâÊï∞ÊçÆ
  const refetchAll = useCallback(async () => {
    if (!isNetworkSupported || !address) return;

    await Promise.all([
      fetchUsdtBalanceWithRetry(),
      fetchAUsdtBalance(),
      fetchAllowance(),
      fetchUserReserveData(),
      fetchUserAccountData(),
    ]);
  }, [
    isNetworkSupported,
    address,
    fetchUsdtBalanceWithRetry,
    fetchAUsdtBalance,
    fetchAllowance,
    fetchUserReserveData,
    fetchUserAccountData,
  ]);

  // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊéàÊùÉ
  const needsApproval = useCallback(
    (amount: string): boolean => {
      if (!amount || parseFloat(amount) <= 0) return false;
      return parseFloat(amount) > parseFloat(allowance);
    },
    [allowance]
  );

  // Ê£ÄÊü•‰ΩôÈ¢ùÊòØÂê¶Ë∂≥Â§ü
  const hasEnoughBalance = useCallback(
    (amount: string): boolean => {
      if (!amount || parseFloat(amount) <= 0) return false;
      return parseFloat(amount) <= parseFloat(usdtBalance);
    },
    [usdtBalance]
  );

  // Ê£ÄÊü•ÊòØÂê¶ÊúâË∂≥Â§üÁöÑaUSDT‰ΩôÈ¢ùÁî®‰∫éÊèêÂèñ
  const hasEnoughATokenBalance = useCallback(
    (amount: string): boolean => {
      if (!amount || parseFloat(amount) <= 0) return false;
      return parseFloat(amount) <= parseFloat(aUsdtBalance);
    },
    [aUsdtBalance]
  );

  // ÊéàÊùÉUSDTÁªôAAVEÊ±† - ‰øÆÂ§ç ethers v6 ÂÖºÂÆπÊÄß
  const approveUsdt = async (amount: string) => {
    if (!aaveConfig || !signer) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.NETWORK_NOT_SUPPORTED);
      return;
    }

    if (!hasEnoughBalance(amount)) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.INSUFFICIENT_BALANCE);
      return;
    }

    setIsLoading(true);
    setIsConfirmed(false);
    setTransactionHash('');

    try {
      const usdtContract = getUsdtContractWithSigner();
      if (!usdtContract) throw new Error('Êó†Ê≥ïËé∑ÂèñUSDTÂêàÁ∫¶');

      const decimals = await usdtContract.decimals();
      const amountInWei = ethers.parseUnits(amount, decimals); // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API

      console.log('üîê ÂºÄÂßãUSDTÊéàÊùÉ:', {
        amount,
        amountInWei: amountInWei.toString(),
        spender: aaveConfig.poolAddress,
        decimals,
      });

      const tx = await usdtContract.approve(aaveConfig.poolAddress, amountInWei);
      setTransactionHash(tx.hash);

      toast.success('ÊéàÊùÉ‰∫§ÊòìÂ∑≤Êèê‰∫§ÔºåÁ≠âÂæÖÁ°ÆËÆ§...');

      const receipt = await tx.wait();
      console.log('‚úÖ USDTÊéàÊùÉÊàêÂäü:', receipt);

      setIsConfirmed(true);
      toast.success('üéâ USDTÊéàÊùÉÊàêÂäüÔºÅ');

      // Âà∑Êñ∞ÊéàÊùÉÈ¢ùÂ∫¶
      await fetchAllowance();
    } catch (error: any) {
      console.error('‚ùå USDTÊéàÊùÉÂ§±Ë¥•:', error);
      toast.error(error.message || AAVE_CONFIG.ERROR_MESSAGES.APPROVAL_FAILED);
    } finally {
      setIsLoading(false);
    }
  };

  // Ë¥®ÊäºUSDTÂà∞AAVE - ‰øÆÂ§ç ethers v6 ÂÖºÂÆπÊÄß
  const supplyUsdt = async (amount: string) => {
    if (!aaveConfig || !signer || !address) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.NETWORK_NOT_SUPPORTED);
      return;
    }

    if (!hasEnoughBalance(amount)) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.INSUFFICIENT_BALANCE);
      return;
    }

    if (needsApproval(amount)) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.INSUFFICIENT_ALLOWANCE);
      return;
    }

    setIsLoading(true);
    setIsConfirmed(false);
    setTransactionHash('');

    try {
      const poolContract = getPoolContract();
      if (!poolContract) throw new Error('Êó†Ê≥ïËé∑ÂèñPoolÂêàÁ∫¶');

      const usdtContract = getUsdtContract();
      if (!usdtContract) throw new Error('Êó†Ê≥ïËé∑ÂèñUSDTÂêàÁ∫¶');

      const decimals = await usdtContract.decimals();
      const amountInWei = ethers.parseUnits(amount, decimals); // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API

      console.log('üí∞ ÂºÄÂßãË¥®ÊäºUSDT:', {
        amount,
        amountInWei: amountInWei.toString(),
        asset: aaveConfig.usdtAddress,
        onBehalfOf: address,
        referralCode: AAVE_CONFIG.DEFAULT_REFERRAL_CODE,
      });

      const tx = await poolContract.supply(
        aaveConfig.usdtAddress,
        amountInWei,
        address,
        AAVE_CONFIG.DEFAULT_REFERRAL_CODE
      );

      setTransactionHash(tx.hash);
      toast.success('Ë¥®Êäº‰∫§ÊòìÂ∑≤Êèê‰∫§ÔºåÁ≠âÂæÖÁ°ÆËÆ§...');

      const receipt = await tx.wait();
      console.log('‚úÖ USDTË¥®ÊäºÊàêÂäü:', receipt);

      setIsConfirmed(true);
      toast.success('üéâ USDTË¥®ÊäºÊàêÂäüÔºÅÂºÄÂßãËµöÂèñÂà©ÊÅØ');

      // Âà∑Êñ∞ÊâÄÊúâÁõ∏ÂÖ≥Êï∞ÊçÆ
      await refetchAll();
    } catch (error: any) {
      console.error('‚ùå USDTË¥®ÊäºÂ§±Ë¥•:', error);
      toast.error(error.message || AAVE_CONFIG.ERROR_MESSAGES.SUPPLY_FAILED);
    } finally {
      setIsLoading(false);
    }
  };

  // ‰ªéAAVEÊèêÂèñUSDT - ‰øÆÂ§ç ethers v6 ÂÖºÂÆπÊÄß
  const withdrawUsdt = async (amount: string) => {
    if (!aaveConfig || !signer || !address) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.NETWORK_NOT_SUPPORTED);
      return;
    }

    // Ê£ÄÊü•ÊèêÂèñÈáëÈ¢ù
    const isMaxWithdraw = amount === 'max';
    const withdrawAmount = isMaxWithdraw ? aUsdtBalance : amount;

    if (!isMaxWithdraw && !hasEnoughATokenBalance(amount)) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.AMOUNT_EXCEEDS_BALANCE);
      return;
    }

    if (parseFloat(aUsdtBalance) <= 0) {
      toast.error(AAVE_CONFIG.ERROR_MESSAGES.NO_DEPOSITS);
      return;
    }

    setIsLoading(true);
    setIsConfirmed(false);
    setTransactionHash('');

    try {
      const poolContract = getPoolContract();
      if (!poolContract) throw new Error('Êó†Ê≥ïËé∑ÂèñPoolÂêàÁ∫¶');

      const usdtContract = getUsdtContract();
      if (!usdtContract) throw new Error('Êó†Ê≥ïËé∑ÂèñUSDTÂêàÁ∫¶');

      const decimals = await usdtContract.decimals();

      // Â¶ÇÊûúÊòØÊúÄÂ§ßÊèêÂèñÔºå‰ΩøÁî®ÁâπÊÆäÂÄº (uint256ÊúÄÂ§ßÂÄº)
      const amountInWei = isMaxWithdraw
        ? ethers.MaxUint256 // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API
        : ethers.parseUnits(withdrawAmount, decimals); // ‰øÆÂ§çÔºö‰ΩøÁî® ethers v6 API

      console.log('üí∏ ÂºÄÂßãÊèêÂèñUSDT:', {
        amount: withdrawAmount,
        isMaxWithdraw,
        amountInWei: amountInWei.toString(),
        asset: aaveConfig.usdtAddress,
        to: address,
      });

      const tx = await poolContract.withdraw(
        aaveConfig.usdtAddress,
        amountInWei,
        address
      );

      setTransactionHash(tx.hash);
      toast.success('ÊèêÂèñ‰∫§ÊòìÂ∑≤Êèê‰∫§ÔºåÁ≠âÂæÖÁ°ÆËÆ§...');

      const receipt = await tx.wait();
      console.log('‚úÖ USDTÊèêÂèñÊàêÂäü:', receipt);

      setIsConfirmed(true);
      toast.success('üéâ USDTÊèêÂèñÊàêÂäüÔºÅ');

      // Âà∑Êñ∞ÊâÄÊúâÁõ∏ÂÖ≥Êï∞ÊçÆ
      await refetchAll();
    } catch (error: any) {
      console.error('‚ùå USDTÊèêÂèñÂ§±Ë¥•:', error);
      toast.error(error.message || AAVE_CONFIG.ERROR_MESSAGES.WITHDRAW_FAILED);
    } finally {
      setIsLoading(false);
    }
  };

  // ËÆ°ÁÆóÈ¢ÑÊúüÊî∂Áõä
  const calculateExpectedReturn = useCallback(
    (amount: string, days: number = 365): string => {
      if (!amount || parseFloat(amount) <= 0 || !depositData.apy) return '0';

      const principal = parseFloat(amount);
      const apy = parseFloat(depositData.apy) / 100; // ËΩ¨Êç¢‰∏∫Â∞èÊï∞
      const expectedReturn = principal * apy * (days / 365);

      return expectedReturn.toFixed(6);
    },
    [depositData.apy]
  );

  // Â¢ûÂº∫ÁöÑÂàùÂßãÂåñÈÄªËæë
  useEffect(() => {
    if (isNetworkSupported && address && provider) {
      console.log('üöÄ ÂàùÂßãÂåñAAVEÊï∞ÊçÆËé∑Âèñ...', {
        isNetworkSupported,
        address,
        chainId,
        aaveConfig: !!aaveConfig
      });

      // Ê£ÄÊü•ÂΩìÂâçÁΩëÁªúÈÖçÁΩÆ
      if (!aaveConfig) {
        console.error('‚ùå ÂΩìÂâçÁΩëÁªú‰∏çÊîØÊåÅÊàñÈÖçÁΩÆÁº∫Â§±');
        toast.error('ÂΩìÂâçÁΩëÁªú‰∏çÊîØÊåÅAAVEÂçèËÆÆ');
        return;
      }

      // È™åËØÅUSDTÂú∞ÂùÄÈÖçÁΩÆ
      if (!aaveConfig.usdtAddress || aaveConfig.usdtAddress === '0x0000000000000000000000000000000000000000') {
        console.error('‚ùå USDTÂú∞ÂùÄÈÖçÁΩÆÊó†Êïà', {
          usdtAddress: aaveConfig.usdtAddress,
          chainId: aaveConfig.chainId
        });
        toast.error('USDTÂêàÁ∫¶Âú∞ÂùÄÈÖçÁΩÆÈîôËØØ');
        return;
      }

      refetchAll();
    }
  }, [isNetworkSupported, address, provider, chainId, aaveConfig, refetchAll]);

  // ÁõëÂê¨‰∫§ÊòìÁ°ÆËÆ§ÂêéÈáçÁΩÆÁä∂ÊÄÅ
  useEffect(() => {
    if (isConfirmed) {
      setTimeout(() => {
        setIsConfirmed(false);
        setTransactionHash('');
      }, 5000);
    }
  }, [isConfirmed]);

  return {
    // ÁΩëÁªúÁä∂ÊÄÅ
    isNetworkSupported,
    aaveConfig,
    
    // ‰ΩôÈ¢ù‰ø°ÊÅØ
    usdtBalance,
    aUsdtBalance,
    allowance,
    
    // Â≠òÊ¨æÂíåÁî®Êà∑Êï∞ÊçÆ
    depositData,
    userData,
    
    // ‰∫§ÊòìÁä∂ÊÄÅ
    isLoading,
    isConfirmed,
    transactionHash,
    
    // Ê£ÄÊü•ÂáΩÊï∞
    needsApproval,
    hasEnoughBalance,
    hasEnoughATokenBalance,
    
    // Êìç‰ΩúÂáΩÊï∞
    approveUsdt,
    supplyUsdt,
    withdrawUsdt,
    refetchAll,
    
    // ËÆ°ÁÆóÂáΩÊï∞
    calculateExpectedReturn,
    
    // Ê†ºÂºèÂåñÂáΩÊï∞
    formatNumber,
    formatApy,
    
    // Ë∞ÉËØïÂáΩÊï∞
    debugUsdtBalance,
  };
};