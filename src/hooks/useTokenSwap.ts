import { useState, useEffect } from "react";
import {
  useAccount,
  useWriteContract,
  useReadContract,
  useWaitForTransactionReceipt,
  useChainId,
} from "wagmi";
import { parseEther, formatEther, parseUnits, formatUnits } from "viem";
import toast from "react-hot-toast";
import {
  getContractAddress,
  isLocalNetwork,
  getNetworkName,
  ERROR_MESSAGES,
} from "../config/tokenSwap";

// ÂêàÁ∫¶ABI
const TOKEN_SWAP_ABI = [
  {
    inputs: [
      { internalType: "address", name: "_tokenAddress", type: "address" },
      { internalType: "uint256", name: "_rate", type: "uint256" }
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [],
    name: "AmountMustBePositive",
    type: "error",
  },
  {
    inputs: [],
    name: "ETHTransferFailed",
    type: "error",
  },
  {
    inputs: [],
    name: "ExcessiveSlippage",
    type: "error",
  },
  {
    inputs: [],
    name: "InsufficientETHBalance",
    type: "error",
  },
  {
    inputs: [],
    name: "InsufficientTokenBalance",
    type: "error",
  },
  {
    inputs: [],
    name: "InsufficientUserTokenBalance",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidFeeRate",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidRate",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidTokenAddress",
    type: "error",
  },
  {
    inputs: [],
    name: "TokenTransferFailed",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "ETHDeposited",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "ETHWithdrawn",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "buyer", type: "address" },
      { indexed: false, internalType: "uint256", name: "ethAmount", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "tokenAmount", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "fee", type: "uint256" }
    ],
    name: "TokensPurchased",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "seller", type: "address" },
      { indexed: false, internalType: "uint256", name: "tokenAmount", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "ethAmount", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "fee", type: "uint256" }
    ],
    name: "TokensSold",
    type: "event",
  },
  {
    inputs: [],
    name: "rate",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
    constant: true,
  },
  {
    inputs: [],
    name: "yiDengToken",
    outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
    stateMutability: "view",
    type: "function",
    constant: true,
  },
  {
    inputs: [{ internalType: "uint256", name: "minTokenAmount", type: "uint256" }],
    name: "buyTokens",
    outputs: [],
    stateMutability: "payable",
    type: "function",
    payable: true,
  },
  {
    inputs: [
      { internalType: "uint256", name: "tokenAmount", type: "uint256" },
      { internalType: "uint256", name: "minETHAmount", type: "uint256" }
    ],
    name: "sellTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "getTokenBalance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
    constant: true,
  },
  {
    inputs: [],
    name: "getETHBalance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
    constant: true,
  },
  {
    inputs: [],
    name: "getFeeRates",
    outputs: [
      { internalType: "uint256", name: "buyFee", type: "uint256" },
      { internalType: "uint256", name: "sellFee", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function",
    constant: true,
  },
] as const;

// ERC20 ABI
const ERC20_ABI = [
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
] as const;

// ÊúÄÂ§ßÊéàÊùÉÈáëÈ¢ùÂ∏∏Èáè
const MAX_UINT256 = "115792089237316195423570985008687907853269984665640564039457584007913129639935";

export function useTokenSwap() {
  const { address, isConnected } = useAccount();
  const chainId = useChainId();
  const [isLoading, setIsLoading] = useState(false);
  const [contractAddress, setContractAddress] = useState<string>();
  const [lastApprovalHash, setLastApprovalHash] = useState<string>();

  // Ëé∑ÂèñÂΩìÂâçÁΩëÁªúÁöÑÂêàÁ∫¶Âú∞ÂùÄ
  useEffect(() => {
    try {
      const addr = getContractAddress(chainId)
      console.log(`üîó ËÆæÁΩÆÂêàÁ∫¶Âú∞ÂùÄ (${chainId}):`, addr)
      setContractAddress(addr)
    } catch (error) {
      console.warn(`‚ùå ‰∏çÊîØÊåÅÁöÑÁΩëÁªú ${chainId}:`, error)
      setContractAddress(undefined)
    }
  }, [chainId]);

  // Ëé∑ÂèñÂÖëÊç¢Áéá
  const { data: exchangeRate, refetch: refetchRate, error: rateError } = useReadContract({
    address: contractAddress as `0x${string}`,
    abi: TOKEN_SWAP_ABI,
    functionName: "rate",
    query: { enabled: !!contractAddress },
  });

  // Ëé∑ÂèñÊâãÁª≠Ë¥πÁéá
  const { data: feeRates, refetch: refetchFees } = useReadContract({
    address: contractAddress as `0x${string}`,
    abi: TOKEN_SWAP_ABI,
    functionName: "getFeeRates",
    query: { enabled: !!contractAddress },
  });

  // Ëé∑ÂèñÂêàÁ∫¶‰∏≠ÁöÑ‰ª£Â∏Å‰ΩôÈ¢ù
  const { data: contractTokenBalance, refetch: refetchContractTokenBalance } = useReadContract({
    address: contractAddress as `0x${string}`,
    abi: TOKEN_SWAP_ABI,
    functionName: "getTokenBalance",
    query: { enabled: !!contractAddress },
  });

  // Ëé∑ÂèñÂêàÁ∫¶‰∏≠ÁöÑETH‰ΩôÈ¢ù
  const { data: contractETHBalance, refetch: refetchContractETHBalance } = useReadContract({
    address: contractAddress as `0x${string}`,
    abi: TOKEN_SWAP_ABI,
    functionName: "getETHBalance",
    query: { enabled: !!contractAddress },
  });

  // Ëé∑Âèñ‰∏ÄÁÅØÂ∏ÅÂêàÁ∫¶Âú∞ÂùÄ
  const { data: yiDengTokenAddress, refetch: refetchTokenAddress, error: tokenAddressError } = useReadContract({
    address: contractAddress as `0x${string}`,
    abi: TOKEN_SWAP_ABI,
    functionName: 'yiDengToken',
    query: { enabled: !!contractAddress }
  })
  
  // Ëé∑ÂèñÁî®Êà∑ÁöÑ‰∏ÄÁÅØÂ∏Å‰ΩôÈ¢ù
  const { 
    data: userTokenBalance, 
    refetch: refetchUserTokenBalance, 
    error: userBalanceError,
    isLoading: isLoadingUserBalance 
  } = useReadContract({
    address: yiDengTokenAddress,
    abi: ERC20_ABI,
    functionName: 'balanceOf',
    args: address ? [address] : undefined,
    query: { 
      enabled: !!yiDengTokenAddress && !!address,
      retry: 3,
      retryDelay: 1000
    }
  })
  
  // Ëé∑ÂèñÁî®Êà∑ÂØπÂêàÁ∫¶ÁöÑÊéàÊùÉÈ¢ùÂ∫¶ - ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂ¢ûÂä†Âà∑Êñ∞È¢ëÁéá
  const { data: allowance, refetch: refetchAllowance } = useReadContract({
    address: yiDengTokenAddress,
    abi: ERC20_ABI,
    functionName: "allowance",
    args: address && yiDengTokenAddress && contractAddress
      ? [address, contractAddress as `0x${string}`]
      : undefined,
    query: { 
      enabled: !!yiDengTokenAddress && !!address && !!contractAddress,
      refetchInterval: 3000, // ÊØè3ÁßíÂà∑Êñ∞ÊéàÊùÉÁä∂ÊÄÅ
    },
  });

  const { writeContract, data: hash, error, isPending } = useWriteContract();
  const { isLoading: isConfirming, isSuccess: isConfirmed } = useWaitForTransactionReceipt({ hash });

  // Âà∑Êñ∞ÊâÄÊúâÊï∞ÊçÆ
  const refetchAll = () => {
    console.log('üîÑ Âà∑Êñ∞ÊâÄÊúâÊï∞ÊçÆ...')
    refetchRate()
    refetchFees()
    refetchContractTokenBalance()
    refetchContractETHBalance()
    refetchTokenAddress()
    refetchUserTokenBalance()
    refetchAllowance()
  }
  
  // ÁõëÂê¨‰∫§ÊòìÁ°ÆËÆ§ÔºåÂà∑Êñ∞Êï∞ÊçÆ
  useEffect(() => {
    if (isConfirmed) {
      console.log('‚úÖ ‰∫§ÊòìÂ∑≤Á°ÆËÆ§ÔºåÂà∑Êñ∞Êï∞ÊçÆ...')
      
      // Â¶ÇÊûúÊòØÊéàÊùÉ‰∫§ÊòìÔºåÁ´ãÂç≥Â§öÊ¨°Âà∑Êñ∞ÊéàÊùÉÁä∂ÊÄÅ
      if (hash === lastApprovalHash) {
        console.log('üîê ÊéàÊùÉ‰∫§ÊòìÂ∑≤Á°ÆËÆ§ÔºåÂº∫Âà∂Âà∑Êñ∞ÊéàÊùÉÁä∂ÊÄÅ')
        refetchAllowance()
        setTimeout(() => refetchAllowance(), 1000)
        setTimeout(() => refetchAllowance(), 3000)
        toast.success('ÊéàÊùÉÂ∑≤ÂÆåÊàêÔºÅÁé∞Âú®ÂèØ‰ª•ËøõË°åÂÖëÊç¢Êìç‰Ωú')
      }
      
      setTimeout(() => refetchAll(), 2000)
    }
  }, [isConfirmed, hash, lastApprovalHash])
  
  // ËÆ°ÁÆóÂáΩÊï∞
  const calculateTokensForETH = (ethAmount: string): string => {
    if (!exchangeRate || !ethAmount || !contractAddress) return "0";
    try {
      const ethInWei = parseEther(ethAmount);
      const grossTokens = ethInWei * BigInt(exchangeRate.toString());
      const fee = feeRates
        ? (grossTokens * BigInt(feeRates[0].toString())) / BigInt(10000)
        : BigInt(0);
      const netTokens = grossTokens - fee;
      return formatUnits(netTokens, 18);
    } catch (error) {
      console.error("ËÆ°ÁÆó‰ª£Â∏ÅÊï∞ÈáèÂ§±Ë¥•:", error);
      return "0";
    }
  }
  
  const calculateETHForTokens = (tokenAmount: string): string => {
    if (!exchangeRate || !tokenAmount || !contractAddress) return "0";
    try {
      const tokensInWei = parseUnits(tokenAmount, 18);
      const grossETH = tokensInWei / BigInt(exchangeRate.toString());
      const fee = feeRates
        ? (grossETH * BigInt(feeRates[1].toString())) / BigInt(10000)
        : BigInt(0);
      const netETH = grossETH - fee;
      return formatEther(netETH);
    } catch (error) {
      console.error("ËÆ°ÁÆóETHÊï∞ÈáèÂ§±Ë¥•:", error);
      return "0";
    }
  }
  
  // Ë¥≠‰π∞‰ª£Â∏ÅÂáΩÊï∞
  const buyTokens = async (ethAmount: string, slippage: number = 1) => {
    if (!isConnected || !address || !exchangeRate || !contractAddress) {
      toast.error(ERROR_MESSAGES.WALLET_NOT_CONNECTED);
      return;
    }

    const expectedTokens = calculateTokensForETH(ethAmount);
    const contractTokens = contractTokenBalance ? parseFloat(contractTokenBalance) : 0;
    if (contractTokens < parseFloat(expectedTokens)) {
      toast.error("ÂêàÁ∫¶‰∏≠‰ª£Â∏ÅÂ∫ìÂ≠ò‰∏çË∂≥ÔºåËØ∑ËÅîÁ≥ªÁÆ°ÁêÜÂëò");
      return;
    }

    try {
      setIsLoading(true);
      const minTokenAmount = parseUnits(
        (parseFloat(expectedTokens) * (1 - slippage / 100)).toFixed(18),
        18
      );

      console.log("Ë¥≠‰π∞ÂèÇÊï∞:", {
        ethAmount,
        expectedTokens,
        minTokenAmount: minTokenAmount.toString(),
        slippage,
        contractAddress,
        userAddress: address
      })
      
      await writeContract({
        address: contractAddress as `0x${string}`,
        abi: TOKEN_SWAP_ABI,
        functionName: "buyTokens",
        args: [minTokenAmount],
        value: parseEther(ethAmount),
      });

      const networkName = getNetworkName(chainId);
      toast.success(`Ë¥≠‰π∞‰∫§ÊòìÂ∑≤Êèê‰∫§Âà∞ ${networkName}`);
    } catch (err: any) {
      console.error("Ë¥≠‰π∞‰ª£Â∏ÅÂ§±Ë¥•:", err);
      let errorMessage = "Ë¥≠‰π∞Â§±Ë¥•";
      if (err.message?.includes("InsufficientTokenBalance")) {
        errorMessage = "ÂêàÁ∫¶‰∏≠‰ª£Â∏ÅÂ∫ìÂ≠ò‰∏çË∂≥";
      } else if (err.message?.includes("ExcessiveSlippage")) {
        errorMessage = "ÊªëÁÇπËøáÂ§ßÔºåËØ∑Â¢ûÂä†ÊªëÁÇπÂÆπÂ∑ÆÊàñÁ®çÂêéÈáçËØï";
      } else if (err.message?.includes("User rejected")) {
        errorMessage = "Áî®Êà∑ÂèñÊ∂à‰∫Ü‰∫§Êòì";
      } else if (err.message) {
        errorMessage = `Ë¥≠‰π∞Â§±Ë¥•: ${err.message}`;
      }
      toast.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }
  
  // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊîπËøõÁöÑÊéàÊùÉÂáΩÊï∞ - ‰ΩøÁî®Êó†ÈôêÊéàÊùÉ
  const approveTokens = async (amount: string) => {
    if (!isConnected || !address || !yiDengTokenAddress || !contractAddress) {
      toast.error('Èí±ÂåÖÊú™ËøûÊé•ÊàñÂêàÁ∫¶Âú∞ÂùÄÊú™Ëé∑Âèñ')
      return
    }

    try {
      setIsLoading(true)
      
      // ÂÖ≥ÈîÆ‰øÆÂ§çÔºö‰ΩøÁî®ÊúÄÂ§ßÂÄºÊéàÊùÉÔºåÁî®Êà∑Âè™ÈúÄÊéàÊùÉ‰∏ÄÊ¨°
      const approvalAmount = BigInt(MAX_UINT256);
      
      console.log('üîê ‰ΩøÁî®Êó†ÈôêÊéàÊùÉÁ≠ñÁï•:', {
        tokenAddress: yiDengTokenAddress,
        spender: contractAddress,
        approvalAmount: "MAX_UINT256",
        userAddress: address
      })
      
      await writeContract({
        address: yiDengTokenAddress,
        abi: ERC20_ABI,
        functionName: "approve",
        args: [contractAddress as `0x${string}`, approvalAmount],
      });

      // Ëé∑ÂèñÂΩìÂâç‰∫§ÊòìÂìàÂ∏åÔºåÁî®‰∫éË∑üË∏™ÊéàÊùÉ‰∫§Êòì
      if (hash) {
        setLastApprovalHash(hash);
      }
      
      toast.success("ÊéàÊùÉ‰∫§ÊòìÂ∑≤Êèê‰∫§ÔºåÁ≠âÂæÖÁ°ÆËÆ§...");
      
    } catch (err: any) {
      console.error("ÊéàÊùÉÂ§±Ë¥•:", err);
      let errorMessage = "ÊéàÊùÉÂ§±Ë¥•";
      if (err.message?.includes("User rejected")) {
        errorMessage = "Áî®Êà∑ÂèñÊ∂à‰∫ÜÊéàÊùÉ";
      } else if (err.message) {
        errorMessage = `ÊéàÊùÉÂ§±Ë¥•: ${err.message}`;
      }
      toast.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }
  
  // Âá∫ÂîÆ‰ª£Â∏ÅÂáΩÊï∞
  const sellTokens = async (tokenAmount: string, slippage: number = 1) => {
    if (!isConnected || !address || !exchangeRate || !contractAddress) {
      toast.error(ERROR_MESSAGES.WALLET_NOT_CONNECTED);
      return;
    }

    // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂú®Âá∫ÂîÆÂâçÂÜçÊ¨°Ê£ÄÊü•ÊéàÊùÉÁä∂ÊÄÅ
    if (needsApproval(tokenAmount)) {
      toast.error("ËØ∑ÂÖàÊéàÊùÉ‰∏ÄÁÅØÂ∏ÅÂêéÂÜçËøõË°åÂÖëÊç¢");
      // Âà∑Êñ∞ÊéàÊùÉÁä∂ÊÄÅÔºåÈò≤Ê≠¢Áä∂ÊÄÅ‰∏çÂêåÊ≠•
      refetchAllowance();
      return;
    }

    const expectedETH = calculateETHForTokens(tokenAmount);
    const contractETH = contractETHBalance ? parseFloat(contractETHBalance) : 0;
    if (contractETH < parseFloat(expectedETH)) {
      toast.error("ÂêàÁ∫¶‰∏≠ETHÂ∫ìÂ≠ò‰∏çË∂≥ÔºåËØ∑ËÅîÁ≥ªÁÆ°ÁêÜÂëò");
      return;
    }

    try {
      setIsLoading(true);
      const minETHAmount = parseEther(
        (parseFloat(expectedETH) * (1 - slippage / 100)).toFixed(18)
      )
      
      console.log('üîÑ Âá∫ÂîÆÂèÇÊï∞:', {
        tokenAmount,
        expectedETH,
        minETHAmount: minETHAmount.toString(),
        slippage,
        userTokenBalance: userTokenBalance?.toString(),
        currentAllowance: allowance?.toString(),
        contractAddress,
        userAddress: address
      })
      
      await writeContract({
        address: contractAddress as `0x${string}`,
        abi: TOKEN_SWAP_ABI,
        functionName: "sellTokens",
        args: [parseUnits(tokenAmount, 18), minETHAmount],
      });

      const networkName = getNetworkName(chainId);
      toast.success(`Âá∫ÂîÆ‰∫§ÊòìÂ∑≤Êèê‰∫§Âà∞ ${networkName}`);
    } catch (err: any) {
      console.error("Âá∫ÂîÆ‰ª£Â∏ÅÂ§±Ë¥•:", err);
      let errorMessage = "Âá∫ÂîÆÂ§±Ë¥•";
      if (err.message?.includes("InsufficientETHBalance")) {
        errorMessage = "ÂêàÁ∫¶‰∏≠ETHÂ∫ìÂ≠ò‰∏çË∂≥";
      } else if (err.message?.includes("InsufficientUserTokenBalance")) {
        errorMessage = "ÊÇ®ÁöÑ‰ª£Â∏Å‰ΩôÈ¢ù‰∏çË∂≥";
      } else if (err.message?.includes("ExcessiveSlippage")) {
        errorMessage = "ÊªëÁÇπËøáÂ§ßÔºåËØ∑Â¢ûÂä†ÊªëÁÇπÂÆπÂ∑ÆÊàñÁ®çÂêéÈáçËØï";
      } else if (err.message?.includes("ERC20: insufficient allowance")) {
        errorMessage = "‰ª£Â∏ÅÊéàÊùÉ‰∏çË∂≥ÔºåËØ∑ÂÖàÊéàÊùÉ";
        setTimeout(() => refetchAllowance(), 1000);
      } else if (err.message?.includes("User rejected")) {
        errorMessage = "Áî®Êà∑ÂèñÊ∂à‰∫Ü‰∫§Êòì";
      } else if (err.message) {
        errorMessage = `Âá∫ÂîÆÂ§±Ë¥•: ${err.message}`;
      }
      toast.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊîπËøõÁöÑÊéàÊùÉÊ£ÄÊü•ÈÄªËæë
  const needsApproval = (tokenAmount: string): boolean => {
    if (!allowance || !tokenAmount || !yiDengTokenAddress || !contractAddress) {
      console.log('üîê ÊéàÊùÉÊ£ÄÊü• - Áº∫Â∞ë‰ø°ÊÅØÔºåÈªòËÆ§ÈúÄË¶ÅÊéàÊùÉ')
      return true;
    }
    
    try {
      const amountInWei = parseUnits(tokenAmount, 18)
      const currentAllowance = BigInt(allowance.toString())
      const needsAuth = currentAllowance < amountInWei
      
      console.log(`üîê ÊéàÊùÉÊ£ÄÊü•ËØ¶ÊÉÖ:`, {
        tokenAmount,
        amountInWei: amountInWei.toString(),
        currentAllowance: currentAllowance.toString(),
        needsAuthorization: needsAuth,
        isInfiniteApproval: currentAllowance.toString() === MAX_UINT256
      })
      
      return needsAuth
    } catch (error) {
      console.error('ÊéàÊùÉÊ£ÄÊü•Âá∫Èîô:', error)
      return true;
    }
  };

  // Ê£ÄÊü•Áî®Êà∑‰ΩôÈ¢ùÊòØÂê¶Ë∂≥Â§ü
  const hasEnoughBalance = (amount: string, type: "token" | "eth"): boolean => {
    if (!amount) return false;
    try {
      if (type === 'token') {
        const amountInWei = parseUnits(amount, 18)
        const hasBalance = userTokenBalance ? BigInt(userTokenBalance.toString()) >= amountInWei : false
        console.log(`üí∞ Ê£ÄÊü•‰ª£Â∏Å‰ΩôÈ¢ù:`, {
          requestedAmount: amount,
          userBalance: userTokenBalance?.toString(),
          hasEnoughBalance: hasBalance
        })
        return hasBalance
      }
      return true;
    } catch {
      return false;
    }
  };

  // Ê£ÄÊü•ÂêàÁ∫¶ÊòØÂê¶ÂèØÁî®
  const isContractAvailable = (): boolean => {
    const available = !!contractAddress && !!exchangeRate
    if (contractAddress && !exchangeRate && rateError) {
      console.error('‚ùå ÂêàÁ∫¶ÂèØËææ‰ΩÜÊó†Ê≥ïËé∑ÂèñÂÖëÊç¢Áéá:', rateError)
    }
    return available
  }
  
  // Ê†ºÂºèÂåñ‰ΩôÈ¢ùÊòæÁ§∫
  const formatUserTokenBalance = (): string => {
    if (!userTokenBalance) return '0'
    try {
      const formatted = formatUnits(userTokenBalance, 18)
      return formatted
    } catch (error) {
      console.error('Ê†ºÂºèÂåñ‰ΩôÈ¢ùÂ§±Ë¥•:', error)
      return '0'
    }
  }

  // ÁõëÂê¨ÊéàÊùÉÁä∂ÊÄÅÂèòÂåñÔºåÊèê‰æõË∞ÉËØï‰ø°ÊÅØ
  useEffect(() => {
    if (allowance) {
      console.log('üîê ÊéàÊùÉÁä∂ÊÄÅÊõ¥Êñ∞:', {
        allowance: allowance.toString(),
        formatted: formatUnits(allowance, 18),
        isInfiniteApproval: allowance.toString() === MAX_UINT256
      })
    }
  }, [allowance])
  
  return {
    // ÁΩëÁªú‰ø°ÊÅØ
    chainId,
    contractAddress,
    networkName: getNetworkName(chainId),
    isLocalNetwork: isLocalNetwork(chainId),
    isContractAvailable: isContractAvailable(),

    // ÂêàÁ∫¶Áä∂ÊÄÅ
    exchangeRate: exchangeRate ? Number(exchangeRate) : 0,
    feeRates: feeRates
      ? {
          buyFee: Number(feeRates[0]) / 100,
          sellFee: Number(feeRates[1]) / 100,
        }
      : { buyFee: 1, sellFee: 1 },
    contractTokenBalance: contractTokenBalance
      ? formatUnits(contractTokenBalance, 18)
      : "0",
    contractETHBalance: contractETHBalance
      ? formatEther(contractETHBalance)
      : "0",

    // Áî®Êà∑Áä∂ÊÄÅ
    userTokenBalance: formatUserTokenBalance(),
    allowance: allowance ? formatUnits(allowance, 18) : '0',
    yiDengTokenAddress,
    
    // Ë∞ÉËØï‰ø°ÊÅØ
    rawUserTokenBalance: userTokenBalance,
    rawAllowance: allowance,
    userBalanceError,
    isLoadingUserBalance,
    
    // ËÆ°ÁÆóÂáΩÊï∞
    calculateTokensForETH,
    calculateETHForTokens,

    // ‰∫§ÊòìÂáΩÊï∞
    buyTokens,
    sellTokens,
    approveTokens,
    needsApproval,
    hasEnoughBalance,
    refetchAll,

    // Âä†ËΩΩÁä∂ÊÄÅ
    isLoading: isLoading || isPending || isConfirming,
    isConfirmed,
    transactionHash: hash,
    error,
  };
}